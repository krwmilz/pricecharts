#!/usr/bin/env perl

use strict;
use warnings;

use Config::Grammar;
use Data::Dumper;
use File::Copy;
use Getopt::Std;
use Lingua::EN::Inflect qw(PL);
use POSIX;
use PriceChart;
use SVG;
use Template;
use Time::Piece;
use URI::Escape;


my %args;
getopts("av", \%args);

$| = 1 if ($args{v});

my $cfg = get_config();
my $dbh = get_dbh($cfg->{http}, undef, $args{v});

my $clause = $args{a} ? "" : "where svg_stale = 1";
my ($n) = $dbh->selectrow_array("select count(*) from products $clause");
if ($n < 1) {
	print "info: nothing stale\n";
	$dbh->disconnect();
	exit;
}

my $work_dir = $cfg->{http}{chroot} . $cfg->{http}{htdocs};
my $svg_dir  = $work_dir . "/svg";
print "info: work, svg dirs $work_dir\{,svg\}\n" if ($args{v});

my $config = {
	INTERPOLATE => 1, POST_CHOMP => 1, EVAL_PERL => 1,
	INCLUDE_PATH => "$work_dir/tt", OUTPUT_PATH => $work_dir
};
my $template = Template->new($config)
	|| die "template: . " . Template->error() . "\n";

#
# manufacturers
#
my $stale_clause = $args{a} ? "" : "and products.svg_stale = 1";
my $stale_list = qq{select distinct prices.manufacturer from prices, products where
	prices.manufacturer = products.manufacturer and
	prices.part_num = products.part_num $stale_clause};

my $types = qq{select distinct products.type from prices, products where
	prices.manufacturer = products.manufacturer and
	prices.part_num = products.part_num and prices.manufacturer = ?
	$stale_clause};

my $products_fine = qq{select distinct manufacturer, part_num from products
	where type = ? and manufacturer = ?};

my $summary = qq{select type, count(*) from products where manufacturer = ? group by type};

my $coarse_list = qq{select manufacturer, count(*) as count, type from products group by
	manufacturer, type};
my @key_fields = ("manufacturer", "type");
my $coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Manufacturers", $coarse, $summary);

#
# retailers
#
if ($args{a}) {
	$stale_list = "select distinct retailer from prices";
} else {
	$stale_list = qq{select distinct prices.retailer from prices, products where
		prices.manufacturer = products.manufacturer and
		prices.part_num = products.part_num and products.svg_stale = 1};
}

$stale_clause = $args{a} ? "" : "and products.svg_stale = 1";
$types = qq{select distinct products.type from prices, products where
	prices.manufacturer = products.manufacturer and
	prices.part_num = products.part_num and prices.retailer = ?
	$stale_clause};

$products_fine = qq{select distinct prices.manufacturer, prices.part_num
	from prices, products where prices.part_num = products.part_num and
	products.manufacturer = prices.manufacturer and products.type = ? and
	prices.retailer = ?};

$summary = qq{select manufacturer, count(*) from prices where retailer = ? group by manufacturer};

$coarse_list = qq{select prices.retailer, count(distinct products.part_num) as
	count, products.type from products, prices where prices.manufacturer =
	products.manufacturer and prices.part_num = products.part_num group by
	prices.retailer, products.type};
@key_fields = ("retailer", "type");
$coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Retailers", $coarse, $summary);

#
# product types
#
$stale_clause = $args{a} ? "" : "and products.svg_stale = 1";
$stale_list = qq{select distinct products.type from products, prices where
	products.manufacturer = prices.manufacturer and
	products.part_num = prices.part_num $stale_clause};

$types = qq{select distinct products.manufacturer from prices, products where
	prices.manufacturer = products.manufacturer and
	prices.part_num = products.part_num and products.type = ?};

$products_fine = qq{select distinct prices.manufacturer, prices.part_num
	from prices, products where prices.part_num = products.part_num and
	products.manufacturer = prices.manufacturer and
	products.manufacturer = ? and products.type = ?};

$summary = qq{select manufacturer, count(*) from products where type = ?
	group by manufacturer};

$coarse_list = qq{select type, count(*) as count, manufacturer from products
	group by type, manufacturer};
@key_fields = ("type", "manufacturer");
$coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Types", $coarse, $summary);

#
# products
#
$stale_clause = $args{a} ? "" : "where svg_stale = 1";
my $sql = "select * from products $stale_clause";
my $products = $dbh->selectall_hashref($sql, "part_num");

$n = scalar keys %$products;
print "info: products:  " if ($args{v});
while (my ($part_num, $row) = each %$products) {
	my $part_num_lc = lc($part_num);
	my $manufacturer_lc = lc($row->{manufacturer});
	spin() if ($args{v});

	$row->{description} =
		get_description($row->{manufacturer}, $row->{part_num});

	$template->process("product.tt", $row,
		"products/$manufacturer_lc/$part_num_lc.html")
		|| die "template: " . $template->error() . "\n";
}
print "\b$n processed\n" if ($args{v});


#
# index
#
$sql = "select manufacturer, part_num from products where first_seen > ? limit 10";
my $new = $dbh->selectall_arrayref($sql, undef, time - (7 * 24 * 60 * 60));

$sql = "select manufacturer, part_num from products where last_scraped > ? order by last_scraped desc";
my $upd = $dbh->selectall_arrayref($sql, undef, time - (0.5 * 60 * 60));

my $cutoff = time - (30 * 24 * 60 * 60);
$sql = "select count(*), count(distinct manufacturer) from products where last_seen > $cutoff";
my ($p, $m) = $dbh->selectrow_array($sql);

$sql = "select count(*) from retailers";
my ($r) = $dbh->selectrow_array($sql);

my $vars = {
	nret => $r, nmanuf => $m, nprod => $p, nnew => scalar @$new,
	news => $new, nupd => scalar @$upd, upds => $upd
};
print "info: index: $p products, $m manufacturers, $r retailers\n" if ($args{v});
$template->process("index.tt", $vars, "index.html")
	or die "template: " . $template->error() . "\n";


#
# svg
#
my ($left, $center, $right, $top, $middle, $bottom) = (3, 957, 40, 15, 150, 20);
my $width = $right + $center + $left;
my $height = $top + $middle + $bottom;

my $where_clause = $args{a} ? "" : "where svg_stale = 1";
$sql = "select manufacturer, part_num from products $where_clause";
my $parts_sth = $dbh->prepare($sql);

$sql = "select distinct retailer from prices where part_num = ? and manufacturer = ?";
my $retailer_sth = $dbh->prepare($sql);

$sql = "select date, price from prices where " .
	"part_num = ? and retailer = ? order by date";
my $point_sth = $dbh->prepare($sql);

$parts_sth->execute();
print "info: svg:  " if ($args{v});
my ($raw_total, $rendered_total, $points, $series) = (0, 0, 0, 0);
while (my ($manufacturer, $part_num) = $parts_sth->fetchrow_array()) {
	$raw_total++;
	spin() if ($args{v});
	my %series;

	$sql = qq{select min(date), max(date), min(price), max(price)
		from prices where manufacturer = ? and part_num = ?};
	my ($x_min, $x_max, $y_min, $y_max) =
		$dbh->selectrow_array($sql, undef, $manufacturer, $part_num);
	next unless (defined $x_min);

	# each series on the chart represents a retailers prices
	$retailer_sth->execute($part_num, $manufacturer);
	while (my ($retailer) = $retailer_sth->fetchrow_array()) {
		$sql = "select url, color from retailers where name = ?";
		my ($url, $color) = $dbh->selectrow_array($sql, undef, $retailer);

		# xlink:href's don't like raw ampersands
		$url =~ s/&/&amp;/g;

		$series{$retailer}{url} = $url;
		$series{$retailer}{color} = $color;

		$point_sth->execute($part_num, $retailer);
		$series{$retailer}{data} = $point_sth->fetchall_arrayref();
		$points += scalar @{$series{$retailer}{data}};
		$series++;
	}

	my $svg = make_svg(\%series, $x_min, $x_max, $y_min, $y_max, $part_num);

	# all links lower case
	my $part_num_cased = $part_num;
	$part_num = lc($part_num);

	# giant hack, if the part number has / in it, make some directories
	if ($part_num =~ /\//) {
		my $needed_dirs = substr($part_num, 0, rindex($part_num, '/'));
		make_path("$svg_dir/$needed_dirs", { verbose => $args{v} });
	}
	open my $svg_fh, ">", "$svg_dir/$part_num.svg" or
		die "couldn't open $svg_dir/$part_num: $!";

	# XXX: not sure how to add this programatically, hack around for now
	my @buf = split("\n", $svg->xmlify);
	my $css_include = "<?xml-stylesheet href=\"/pricechart.css\" type=\"text/css\"?>";
	# must be the second line
	splice (@buf, 1, 0, ($css_include));

	print $svg_fh "$_\n" for (@buf);
	close $svg_fh;

	$rendered_total++;
}
printf "\b%i rendered, %i skipped, ", $rendered_total, $raw_total - $rendered_total if ($args{v});
printf "%i points in %i series\n", $points, $series if ($args{v});

$dbh->do("update products set svg_stale = 0");

$dbh->disconnect();


#
# generate an entire tree of html structure
#
sub generate_folder
{
	my $sql_stale_outer = shift;
	my $sql_types = shift;
	my $sql_products = shift;
	my $name = shift;
	my $coarse_list = shift;
	my $sql_summary = shift;

	my $name_lc = lc ($name);
	print "info: $name_lc:  " if ($args{v});

	my $stale_list = $dbh->selectcol_arrayref($sql_stale_outer);
	my $num = scalar @$stale_list;
	for my $it (@$stale_list) {

		my $it_link = linkify($it);
		my $types = $dbh->selectcol_arrayref($sql_types, undef, $it);
		for my $type (sort @$types) {
			spin() if ($args{v});

			my $products = $dbh->selectall_arrayref($sql_products, undef, $type, $it);
			$_->[2] = get_description($_->[0], $_->[1]) for (@$products);

			my $vars = {
				name => $it, type => PL($type, scalar @$products),
				products => $products
			};
			my $type_link = linkify($type);
			my $out_path = "$name_lc/$it_link/$type_link.html";
			$template->process("fine_list.tt", $vars, $out_path)
				or die "template: " . $template->error() . "\n";
		}

		my $summary = $dbh->selectall_arrayref($sql_summary, undef, $it);
		my $vars = { type => $name_lc, name => $it, info => $summary };
		$template->process("summary.tt", $vars, "$name_lc/$it_link.html")
			or die "template: " . $template->error() . "\n";
	}
	print "\b$num processed\n" if ($args{v});

	my $vars = { name => $name, list => $coarse_list };
	$template->process("coarse_list.tt", $vars, "$name_lc.html")
		or die "template: " . $template->error() . "\n";
}

sub linkify
{
	my $type = shift;

	my $type_link = lc($type);
	$type_link =~ s/ /_/;
	return $type_link;
}

sub get_description
{
	my $manufacturer = shift;
	my $part_num = shift;

	my $sql = "select description from descriptions where " .
		"manufacturer = ? and part_num = ? order by date";
	my $descriptions = $dbh->selectcol_arrayref($sql, undef, $manufacturer,
		$part_num);
	unless (@$descriptions) {
		print "error: no descriptions for $manufacturer $part_num\n";
	}

	# pick the shortest non-zero description
	my $best = $descriptions->[0];
	for (@$descriptions) {
		next if ($_ eq "");
		$best = $_ if (length($_) < length($best));
	}

	return $best;
}


#
# make a new svg with provided coordinate and label data
#
sub make_svg
{
	my $series = shift;
	my $x_min = shift;
	my $x_max = shift;
	my $y_min = shift;
	my $y_max = shift;
	my $part_num = shift;

	$y_max = ceil($y_max / 100) * 100;
	$y_min = floor($y_min / 100) * 100;

	my ($domain, $range) = ($x_max - $x_min, $y_max - $y_min);
	$domain = 24 * 60 * 60 if ($domain <= 0);
	$range = 20 if ($range < 20);

	# clamp the total size of this thing with viewBox
	my $svg = SVG->new(viewBox => "0 0 $width $height");
	my $defs = $svg->defs();
	my ($x_scale, $y_scale) = ($center / $domain, $middle / $range);

	# make price labels along right side and lines across chart
	my $num_labels = 5;
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);
		my $price = ceil($y_max - $range * $step);
		my $y = $top + $middle * $step;

		$svg->text(
			id => "price_$_", x => $left + $center + 5, y => $y + 3,
			class => "chart_price", "text-anchor" => "start"
		)->cdata("\$$price");

		$svg->line(
			id => "horizontal_line_$_", x1 => $left, y1 => $y,
			x2 => $width - $right, y2 => $y, class => "chart_rulers"
		);
	}

	# make dates along the bottom
	if ($domain == 24 * 60 * 60) {
		$num_labels = 2;
	}
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);

		# make the dates not hang off the ends of the chart
		my $text_anchor = "middle";
		$text_anchor = "start" if ($_ == 1);
		$text_anchor = "end" if ($_ == $num_labels);

		# print the dates along the x axis
		my $x = $left + $center * $step;
		my $time = $x_min + $domain * $step;
		$svg->text(id => "date_$_", x => $x, y => $height - 5,
			class => "chart_date", "text-anchor" => $text_anchor
		)->cdata(strftime("%B %e, %Y", localtime($time)));

		# print the little tick marks down from the x axis
		my $x_axis = $top + $middle;
		$svg->line(id => "date_marker_$_", x1 => $x, y1 => $x_axis,
			x2 => $x, y2 => $x_axis + 5, class => "chart_rulers",
		);
	}

	while (my ($retailer, $values) = each %$series) {
		my $retailer_id = lc($retailer);
		$retailer_id =~ s/ /_/;

		my $url = $values->{url};
		my $color = $values->{color};

		my (@xs, @ys, @pts);
		for (@{$values->{data}}) {
			my ($x, $y) = @$_;
			push @xs, sprintf "%.3f", ($x - $x_min) * $x_scale + $left;
			push @ys, sprintf "%.3f", $height - $bottom - ($y - $y_min) * $y_scale;
			push @pts, $xs[-1];
			push @pts, $ys[-1];
		}

		if (@pts < 6) {
			my $points = $svg->get_path(x => \@xs, y => \@ys, -type => "path");
			$defs->path(%$points, id => "path_$retailer_id");
		}
		else {
			# catmull rom time
			my $d = catmullrom_to_bezier(\@pts);
			$defs->tag("path", "d" => $d, id => "path_$retailer_id");
		}

		# the line, points, and label can be grouped under one anchor
		my $anchor = $svg->anchor(-href => $url . $part_num,
			target => "new_window");

		# draw path first
		$anchor->use(-href => "#path_$retailer_id",
			class => "chart_series", style => "stroke: #$color"
		);

		# now draw individual data points
		$defs->circle(id => "data_point_$retailer", cx => 0, cy => 0,
			class => "chart_data", r => 2, style => "stroke: #$color;"
		);
		while (my $i = each @xs) {
			$anchor->use(-href => "#data_point_$retailer",
				x => $xs[$i], y => $ys[$i]
			);
		}

		# show retailer name along the start of the path
		$anchor->text(class => "chart_series_text", fill => "#$color"
		)->tag("textPath", -href => "#path_$retailer_id"
		)->tag("tspan", "dy" => "-5")->cdata($retailer);
	}

	# when graph is loaded make a sliding motion show the graph lines
	# my $mask = $svg->rectangle(
	# 	x => 0, y => 0, width => 1000, height => 250, rx => 0, ry => 0,
	# 	id => "mask", fill => "#FFF"
	# );
	# $mask->animate(
	# 	attributeName => "x", values => "0;1000", dur => "0.2s",
	# 	fill => "freeze", -method => ""
	# );

	return $svg
}

#
# taken from https://gist.github.com/njvack/6925609
#
sub catmullrom_to_bezier
{
	my $pts_ref = shift;
	my @pts = @$pts_ref;

	# catmull-rom to cubic bezier conversion matrix
	# 0    1    0    0
	# -1/6 1    1/6  0
	# 0    1/6  1    -1/6
	# 0    0    1    0

	my $d = "M" . $pts[0] . ", " . $pts[1] . " ";
	my $iLen = @pts;
	for (my $i = 0; $iLen - 2 > $i; $i += 2) {
		my @p;
		if ($i == 0) {
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 4], y => $pts[$i + 5]};
		}
		elsif ($i == ($iLen - 4)) {
			push @p, {x => $pts[$i - 2], y => $pts[$i - 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
		}
		else {
			push @p, {x => $pts[$i - 2], y => $pts[$i - 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 4], y => $pts[$i + 5]};
		}

		#	print Dumper(@p);

		my @bp;
		push @bp, {x => $p[1]{x}, y => $p[1]{y}};
		push @bp, {
			x => ((-$p[0]{x} + 6*$p[1]{x} + $p[2]{x}) / 6),
			y => ((-$p[0]{y} + 6*$p[1]{y} + $p[2]{y}) / 6)
		};
		push @bp, {
			x => (($p[1]{x} + 6*$p[2]{x} - $p[3]{x}) / 6),
			y => (($p[1]{y} + 6*$p[2]{y} - $p[3]{y}) / 6)
		};
		push @bp, {x => $p[2]{x}, y => $p[2]{y}};

		$d .= "C " . $bp[1]{x} . ", " . $bp[1]{y} . " " .
			$bp[2]{x} . ", " . $bp[2]{y} . " " .
			$bp[3]{x} . ", " . $bp[3]{y} . " ";
	}

	# print $d;
	return $d;
}
