#!/usr/bin/env perl

use strict;
use warnings;

use Config::Grammar;
use Getopt::Std;
use Lingua::EN::Inflect qw(PL);
use POSIX;
use PriceChart;
use SVG;
use Template;


my %args;
getopts("av", \%args);

$| = 1 if ($args{v});

my $cfg = get_config();
my $dbh = get_dbh($cfg->{general}{db_dir}, $args{v});

my $work_dir = $cfg->{http}{htdocs};
my $svg_dir  = $work_dir . "/svg";
print "info: work, svg dirs $work_dir\{,svg\}\n" if ($args{v});

my $config = {
	INTERPOLATE => 1, POST_CHOMP => 1, EVAL_PERL => 1,
	INCLUDE_PATH => "$work_dir/tt", OUTPUT_PATH => $work_dir
};
my $www = Template->new($config) || die Template->error(), "\n";

my $and_stale = $args{a} ? "" : "and products.svg_stale = 1";
my $where_stale = $args{a} ? "" : "where svg_stale = 1";
my $part_equality = qq{prices.manufacturer = products.manufacturer and
	prices.part_num = products.part_num};

#
# manufacturers
#
my $stale_list = qq{select distinct prices.manufacturer from prices, products where
	$part_equality $and_stale};

my $types = qq{select distinct products.type from prices, products where
	$part_equality and prices.manufacturer = ? $and_stale};

my $products_fine = qq{select distinct products.manufacturer, products.part_num
	from products, prices where $part_equality and products.type = ? and
	products.manufacturer = ?};

my $summary = qq{select type, count(*) from products where manufacturer = ? group by type};

my $coarse_list = qq{select products.manufacturer, count(distinct products.part_num)
	as count, products.type from products, prices where $part_equality
	group by products.manufacturer, products.type};
my @key_fields = ("manufacturer", "type");
my $coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Manufacturers", $coarse, $summary);

#
# retailers
#
$stale_list = qq{select distinct prices.retailer from prices, products where
	$part_equality $and_stale};

$types = qq{select distinct products.type from prices, products where
	$part_equality and prices.retailer = ?  $and_stale};

$products_fine = qq{select distinct prices.manufacturer, prices.part_num
	from prices, products where $part_equality and products.type = ? and
	prices.retailer = ?};

$summary = qq{select manufacturer, count(*) from prices where retailer = ?
	group by manufacturer};

$coarse_list = qq{select prices.retailer, count(distinct products.part_num) as
	count, products.type from products, prices where $part_equality group by
	prices.retailer, products.type};
@key_fields = ("retailer", "type");
$coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Retailers", $coarse, $summary);

#
# product types
#
$stale_list = qq{select distinct products.type from products, prices where
	$part_equality $and_stale};

$types = qq{select distinct products.manufacturer from prices, products where
	$part_equality and products.type = ?};

$products_fine = qq{select distinct prices.manufacturer, prices.part_num
	from prices, products where $part_equality and products.manufacturer = ?
	and products.type = ?};

$summary = qq{select manufacturer, count(*) from products where type = ?
	group by manufacturer};

$coarse_list = qq{select type, count(*) as count, manufacturer from products
	group by type, manufacturer};
@key_fields = ("type", "manufacturer");
$coarse = $dbh->selectall_hashref($coarse_list, \@key_fields);

generate_folder($stale_list, $types, $products_fine, "Types", $coarse, $summary);

#
# products
#
print "info: products: " if ($args{v});

my $sql = "select * from products $where_stale";
my $products = $dbh->selectall_hashref($sql, "part_num");
while (my ($part_num, $row) = each %$products) {
	my $part_link = linkify($part_num);
	my $manuf_link = linkify($row->{manufacturer});

	$row->{description} =
		get_description($row->{manufacturer}, $row->{part_num});

	my $url = "products/$manuf_link/$part_link.html";
	$www->process("product.tt", $row, $url) or die $www->error(), "\n";
}
print scalar(keys %$products) . " processed\n" if ($args{v});

#
# index
#
print "info: index: ";

$sql = "select manufacturer, part_num from products order by first_seen desc limit 5";
my $new = $dbh->selectall_arrayref($sql);

$sql = qq{select manufacturer, part_num from products order by last_scraped desc limit 5};
my $upd = $dbh->selectall_arrayref($sql);

$sql = "select count(*), count(distinct manufacturer) from products where last_seen > ?";
my ($p, $m) = $dbh->selectrow_array($sql, undef, time - (30 * 24 * 60 * 60));

$sql = "select count(*) from retailers";
my ($r) = $dbh->selectrow_array($sql);

my $vars = { nret => $r, nmanuf => $m, nprod => $p, news => $new, upds => $upd };
$www->process("index.tt", $vars, "index.html") or die $www->error(), "\n";

print "$p products, $m manufacturers, $r retailers\n" if ($args{v});

#
# svg
#
print "info: svg:  " if ($args{v});

my @series_keys = ("retailer", "date");
$sql = "select retailer, date, price from prices where manufacturer = ? and
	part_num = ?";
my $series_sth = $dbh->prepare($sql);

$sql = qq{select min(date), max(date), min(price), max(price) from prices
	where manufacturer = ? and part_num = ?};
my $extremes_sth = $dbh->prepare($sql);

$sql = "select name, url, color from retailers";
my $retailer_info = $dbh->selectall_hashref($sql, "name");

my ($total, $rendered) = (0, 0);

my $parts_sql = "select manufacturer, part_num from products $where_stale";
for (@{$dbh->selectall_arrayref($parts_sql)}) {
	my ($manufacturer, $part_num) = @$_;

	$total++;
	spin() if ($args{v});

	my ($x_min, $x_max, $y_min, $y_max) =
		$dbh->selectrow_array($extremes_sth, undef, $manufacturer, $part_num);
	next unless (defined $x_min);

	my $series = $dbh->selectall_hashref($series_sth, \@series_keys, undef,
		$manufacturer, $part_num);
	my $svg = make_svg($series, $x_min, $x_max, $y_min, $y_max, $part_num, $retailer_info);

	my $manufacturer_dir = linkify($manufacturer);
	my $part_link = linkify($part_num);

	make_path("$svg_dir/$manufacturer_dir", { verbose => $args{v} });
	my $svg_path = "$svg_dir/$manufacturer_dir/$part_link.svg";

	open my $svg_fh, ">", "$svg_path" or die "couldn't open $svg_path: $!";
	print $svg_fh $svg->xmlify;
	close $svg_fh;

	$rendered++;
}
printf "\b$rendered rendered, %i skipped\n", $total - $rendered if ($args{v});

$dbh->do("update products set svg_stale = 0");
$dbh->disconnect();

#
# generate an entire tree of html structure
#
sub generate_folder
{
	my $sql_stale_outer = shift;
	my $sql_types = shift;
	my $sql_products = shift;
	my $name = shift;
	my $coarse_list = shift;
	my $sql_summary = shift;

	my $name_lc = lc ($name);
	print "info: $name_lc:  " if ($args{v});

	my $stale_list = $dbh->selectcol_arrayref($sql_stale_outer);
	for my $it (@$stale_list) {
		spin() if ($args{v});

		my $it_link = linkify($it);
		my $types = $dbh->selectcol_arrayref($sql_types, undef, $it);
		for my $type (sort @$types) {

			my $products = $dbh->selectall_arrayref($sql_products, undef, $type, $it);
			$_->[2] = get_description($_->[0], $_->[1]) for (@$products);

			my $vars = {
				name => $it, type => PL($type, scalar @$products),
				products => $products
			};
			my $type_link = linkify($type);
			my $out_path = "$name_lc/$it_link/$type_link.html";
			$www->process("fine_list.tt", $vars, $out_path)
				or die $www->error(), "\n";
		}

		my $summary = $dbh->selectall_arrayref($sql_summary, undef, $it);
		my $vars = { type => $name_lc, name => $it, info => $summary };
		$www->process("summary.tt", $vars, "$name_lc/$it_link.html")
			or die $www->error(), "\n";
	}

	my $vars = { name => $name, list => $coarse_list };
	$www->process("coarse_list.tt", $vars, "$name_lc.html")
		or die $www->error(), "\n";

	print "\b" . scalar @$stale_list . " processed\n" if ($args{v});
}

sub linkify
{
	my $type = shift;

	my $type_link = lc($type);
	$type_link =~ s/[ #\/]/_/g;
	return $type_link;
}

sub get_description
{
	my $manufacturer = shift;
	my $part_num = shift;

	my $sql = "select description from descriptions where " .
		"manufacturer = ? and part_num = ? order by date";
	my $descriptions = $dbh->selectcol_arrayref($sql, undef, $manufacturer,
		$part_num);
	unless (@$descriptions) {
		print "error: no descriptions for $manufacturer $part_num\n";
	}

	# pick the shortest non-zero description
	my $best = $descriptions->[0];
	for (@$descriptions) {
		next if ($_ eq "");
		$best = $_ if (length($_) < length($best));
	}

	return $best;
}

#
# make a new svg with provided coordinate and label data
#
sub make_svg
{
	my $series = shift;
	my $x_min = shift;
	my $x_max = shift;
	my $y_min = shift;
	my $y_max = shift;
	my $part_num = shift;
	my $retailer_info = shift;

	my ($left, $center, $right, $top, $middle, $bottom) = (3, 957, 40, 15, 150, 20);
	my $width = $right + $center + $left;
	my $height = $top + $middle + $bottom;

	$y_max = ceil($y_max / 100) * 100;
	$y_min = floor($y_min / 100) * 100;

	my ($domain, $range) = ($x_max - $x_min, $y_max - $y_min);
	$domain = 24 * 60 * 60 if ($domain <= 0);
	$range = 20 if ($range < 20);

	# clamp the total size of this thing with viewBox
	my $svg = SVG->new(viewBox => "0 0 $width $height");
	my $defs = $svg->defs();
	my ($x_scale, $y_scale) = ($center / $domain, $middle / $range);

	$defs->tag("link", href => "/pricechart.css", type => "text/css",
		rel => "stylesheet", xmlns => "http://www.w3.org/1999/xhtml");

	# make price labels along right side and lines across chart
	my $num_labels = 5;
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);
		my $price = ceil($y_max - $range * $step);
		my $y = $top + $middle * $step;

		$svg->text(
			id => "price_$_", x => $left + $center + 5, y => $y + 3,
			class => "chart_price", "text-anchor" => "start"
		)->cdata("\$$price");

		$svg->line(
			id => "horizontal_line_$_", x1 => $left, y1 => $y,
			x2 => $width - $right, y2 => $y, class => "chart_rulers"
		);
	}

	# make dates along the bottom
	if ($domain == 24 * 60 * 60) {
		$num_labels = 2;
	}
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);

		# make the dates not hang off the ends of the chart
		my $text_anchor = "middle";
		$text_anchor = "start" if ($_ == 1);
		$text_anchor = "end" if ($_ == $num_labels);

		# print the dates along the x axis
		my $x = $left + $center * $step;
		my $time = $x_min + $domain * $step;
		$svg->text(id => "date_$_", x => $x, y => $height - 5,
			class => "chart_date", "text-anchor" => $text_anchor
		)->cdata(strftime("%B %e, %Y", localtime($time)));

		# print the little tick marks down from the x axis
		my $x_axis = $top + $middle;
		$svg->line(id => "date_marker_$_", x1 => $x, y1 => $x_axis,
			x2 => $x, y2 => $x_axis + 5, class => "chart_rulers",
		);
	}

	while (my ($retailer, $values) = each %$series) {
		my $retailer_id = lc($retailer);
		$retailer_id =~ s/ /_/;

		my (@xs, @ys, @pts);
		for (sort keys %{$values}) {
			my ($x, $y) = ($_, $values->{$_}{price});
			push @xs, sprintf "%.3f", ($x - $x_min) * $x_scale + $left;
			push @ys, sprintf "%.3f", $height - $bottom - ($y - $y_min) * $y_scale;
			push @pts, $xs[-1];
			push @pts, $ys[-1];
		}

		if (@pts < 6) {
			my $points = $svg->get_path(x => \@xs, y => \@ys, -type => "path");
			$defs->path(%$points, id => "path_$retailer_id");
		}
		else {
			# catmull rom time
			my $d = catmullrom_to_bezier(\@pts);
			$defs->tag("path", "d" => $d, id => "path_$retailer_id");
		}

		my $info = $retailer_info->{$retailer};
		my ($url, $color) = ($info->{url}, $info->{color});

		# xlink:href's don't like raw ampersands
		$url =~ s/&/&amp;/g;

		# the line, points, and label can be grouped under one anchor
		my $anchor = $svg->anchor(-href => $url . $part_num,
			target => "new_window");

		# draw path first
		$anchor->use(-href => "#path_$retailer_id",
			class => "chart_series", style => "stroke: #$color"
		);

		# now draw individual data points
		$defs->circle(id => "data_point_$retailer", cx => 0, cy => 0,
			class => "chart_data", r => 2, style => "stroke: #$color;"
		);
		while (my $i = each @xs) {
			$anchor->use(-href => "#data_point_$retailer",
				x => $xs[$i], y => $ys[$i]
			);
		}

		# show retailer name along the start of the path
		$anchor->text(class => "chart_retailer_text", fill => "#$color"
		)->tag("textPath", -href => "#path_$retailer_id"
		)->tag("tspan", "dy" => "-5")->cdata($retailer);
	}

	# when graph is loaded make a sliding motion show the graph lines
	# my $mask = $svg->rectangle(
	# 	x => 0, y => 0, width => 1000, height => 250, rx => 0, ry => 0,
	# 	id => "mask", fill => "#FFF"
	# );
	# $mask->animate(
	# 	attributeName => "x", values => "0;1000", dur => "0.2s",
	# 	fill => "freeze", -method => ""
	# );

	return $svg
}

#
# taken from https://gist.github.com/njvack/6925609
#
sub catmullrom_to_bezier
{
	my $pts_ref = shift;
	my @pts = @$pts_ref;

	# catmull-rom to cubic bezier conversion matrix
	# 0    1    0    0
	# -1/6 1    1/6  0
	# 0    1/6  1    -1/6
	# 0    0    1    0

	my $d = "M $pts[0], $pts[1] ";
	my $iLen = @pts;
	for (my $i = 0; $iLen - 2 > $i; $i += 2) {
		my (@xs, @ys);
		if ($i == 0) {
			push @xs, $pts[$i];	push @ys, $pts[$i + 1];
			push @xs, $pts[$i];	push @ys, $pts[$i + 1];
			push @xs, $pts[$i + 2];	push @ys, $pts[$i + 3];
			push @xs, $pts[$i + 4];	push @ys, $pts[$i + 5];
		}
		elsif ($i == ($iLen - 4)) {
			push @xs, $pts[$i - 2];	push @ys, $pts[$i - 1];
			push @xs, $pts[$i];	push @ys, $pts[$i + 1];
			push @xs, $pts[$i + 2];	push @ys, $pts[$i + 3];
			push @xs, $pts[$i + 2];	push @ys, $pts[$i + 3];
		}
		else {
			push @xs, $pts[$i - 2];	push @ys, $pts[$i - 1];
			push @xs, $pts[$i];	push @ys, $pts[$i + 1];
			push @xs, $pts[$i + 2];	push @ys, $pts[$i + 3];
			push @xs, $pts[$i + 4];	push @ys, $pts[$i + 5];
		}

		my (@bp_x, @bp_y);
		push @bp_x, $xs[1];	push @bp_y, $ys[1];
		push @bp_x, ((-$xs[0] + 6*$xs[1] + $xs[2]) / 6);
		push @bp_y, ((-$ys[0] + 6*$ys[1] + $ys[2]) / 6);
		push @bp_x, (($xs[1] + 6*$xs[2] - $xs[3]) / 6);
		push @bp_y, (($ys[1] + 6*$ys[2] - $ys[3]) / 6);
		push @bp_x, $xs[2];	push @bp_y, $ys[2];

		$d .= "C $bp_x[1], $bp_y[1] $bp_x[2], $bp_y[2] $bp_x[3], $bp_y[3] ";
	}

	return $d;
}
