#!/usr/bin/env perl

use strict;
use warnings;

use Config::Grammar;
use Getopt::Std;
use SVG;
use POSIX;
use PriceChart;


my %args;
getopts("anv", \%args);

$| = 1 if ($args{v});

my $cfg = get_config();
my $dbh = get_dbh($cfg->{http}, undef, $args{v});

my $svg_dir = $cfg->{http}{chroot} . $cfg->{http}{htdocs} . "/svg";

# we don't output svg's when -n is given
print "info: output dir is $svg_dir\n" if ($args{v} && !$args{n});

my ($left, $center, $right, $top, $middle, $bottom) = (3, 957, 40, 15, 150, 20);
my $width = $right + $center + $left;
my $height = $top + $middle + $bottom;

print "info: l, c, r, w = $left, $center, $right, $width\n" if ($args{v});
print "info: t, m, b, h = $top, $middle, $bottom, $height\n" if ($args{v});

my $where_clause = $args{a} ? "" : "where svg_stale = 1";
my $sql = "select manufacturer, part_num from products $where_clause";
my $parts_sth = $dbh->prepare($sql);

$sql = "select distinct retailer from prices where part_num = ? and manufacturer = ?";
my $retailer_sth = $dbh->prepare($sql);

$sql = "select date, price from prices where " .
	"part_num = ? and retailer = ? order by date";
my $point_sth = $dbh->prepare($sql);

$sql = "update products set svg_stale = 0 where manufacturer = ? and part_num = ?";
my $success_sth = $dbh->prepare($sql);

$parts_sth->execute();
print "info: generating  " if ($args{v});
my ($raw_total, $rendered_total, $points, $series) = (0, 0, 0, 0);
while (my ($manufacturer, $part_num) = $parts_sth->fetchrow_array()) {
	$raw_total++;
	spin() if ($args{v});

	# make sure we have at least two prices to work with
	$sql = "select min(date), max(date), min(price), max(price) " .
		"from prices where part_num = ? and manufacturer = ?";
	my ($x_min, $x_max, $y_min, $y_max) =
		$dbh->selectrow_array($sql, undef, $part_num, $manufacturer);
	next unless (defined $x_min);

	$y_max = ceil($y_max / 100) * 100;
	$y_min = floor($y_min / 100) * 100;

	my ($domain, $range) = ($x_max - $x_min, $y_max - $y_min);
	$domain = 24 * 60 * 60 if ($domain <= 0);
	$range = 20 if ($range < 20);

	# clamp the total size of this thing with viewBox
	my $svg = SVG->new(viewBox => "0 0 $width $height");
	my $defs = $svg->defs();
	my ($x_scale, $y_scale) = ($center / $domain, $middle / $range);

	# make price labels along right side and lines across chart
	my $num_labels = 5;
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);
		my $price = ceil($y_max - $range * $step);
		my $y = $top + $middle * $step;

		$svg->text(
			id => "price_$_", x => $left + $center + 5, y => $y + 3,
			class => "chart_price", "text-anchor" => "start"
		)->cdata("\$$price");

		$svg->line(
			id => "horizontal_line_$_", x1 => $left, y1 => $y,
			x2 => $width - $right, y2 => $y, class => "chart_rulers"
		);
	}

	# make dates along the bottom
	if ($domain == 24 * 60 * 60) {
		$num_labels = 2;
	}
	for (1..$num_labels) {
		my $step = ($_ - 1) / ($num_labels - 1);

		# make the dates not hang off the ends of the chart
		my $text_anchor = "middle";
		$text_anchor = "start" if ($_ == 1);
		$text_anchor = "end" if ($_ == $num_labels);

		# print the dates along the x axis
		my $x = $left + $center * $step;
		my $time = $x_min + $domain * $step;
		$svg->text(id => "date_$_", x => $x, y => $height - 5,
			class => "chart_date", "text-anchor" => $text_anchor
		)->cdata(strftime("%B %e, %Y", localtime($time)));

		# print the little tick marks down from the x axis
		my $x_axis = $top + $middle;
		$svg->line(id => "date_marker_$_", x1 => $x, y1 => $x_axis,
			x2 => $x, y2 => $x_axis + 5, class => "chart_rulers",
		);
	}

	# each series on the chart represents a retailers prices
	$retailer_sth->execute($part_num, $manufacturer);
	while (my ($retailer) = $retailer_sth->fetchrow_array()) {
		my $retailer_id = lc($retailer);
		$retailer_id =~ s/ /_/;

		$sql = "select url, color from retailers where name = ?";
		my ($url, $color) = $dbh->selectrow_array($sql, undef, $retailer);

		# xlink:href's don't like raw ampersands
		$url =~ s/&/&amp;/g;

		# get all prices that we've scraped per product per retailer
		my (@xs, @ys, @pts);
		$point_sth->execute($part_num, $retailer);
		while (my ($date, $price) = $point_sth->fetchrow_array) {
			# transform and clamp real world coordinates
			push @xs, sprintf "%.3f", ($date - $x_min) * $x_scale + $left;
			push @ys, sprintf "%.3f", $height - $bottom - ($price - $y_min) * $y_scale;
			push @pts, $xs[-1];
			push @pts, $ys[-1];
			$points++;
		}

		if (@pts < 6) {
			my $points = $svg->get_path(x => \@xs, y => \@ys, -type => "path");
			$defs->path(%$points, id => "path_$retailer_id");
		}
		else {
			# catmull rom time
			my $d = catmullrom_to_bezier(\@pts);
			$defs->tag("path", "d" => $d, id => "path_$retailer_id");
		}

		# the line, points, and label can be grouped under one anchor
		my $anchor = $svg->anchor(-href => $url . $part_num,
			target => "new_window");

		# draw path first
		$anchor->use(-href => "#path_$retailer_id",
			class => "chart_series", style => "stroke: #$color"
		);

		# now draw individual data points
		$defs->circle(id => "data_point_$retailer", cx => 0, cy => 0,
			class => "chart_data", r => 2, style => "stroke: #$color;"
		);
		while (my $i = each @xs) {
			$anchor->use(-href => "#data_point_$retailer",
				x => $xs[$i], y => $ys[$i]
			);
		}

		# show retailer name along the start of the path
		$anchor->text(class => "chart_series_text", fill => "#$color"
		)->tag("textPath", -href => "#path_$retailer_id"
		)->tag("tspan", "dy" => "-5")->cdata($retailer);

		$series++;
	}

	# when graph is loaded make a sliding motion show the graph lines
	# my $mask = $svg->rectangle(
	# 	x => 0, y => 0, width => 1000, height => 250, rx => 0, ry => 0,
	# 	id => "mask", fill => "#FFF"
	# );
	# $mask->animate(
	# 	attributeName => "x", values => "0;1000", dur => "0.2s",
	# 	fill => "freeze", -method => ""
	# );

	next if ($args{n});

	# all links lower case
	my $part_num_cased = $part_num;
	$part_num = lc($part_num);

	# giant hack, if the part number has / in it, make some directories
	if ($part_num =~ /\//) {
		my $needed_dirs = substr($part_num, 0, rindex($part_num, '/'));
		make_path("$svg_dir/$needed_dirs", { verbose => $args{v} });
	}
	open my $svg_fh, ">", "$svg_dir/$part_num.svg" or
		die "couldn't open $svg_dir/$part_num: $!";

	# XXX: not sure how to add this programatically, hack around for now
	my @buf = split("\n", $svg->xmlify);
	my $css_include = "<?xml-stylesheet href=\"/pricechart.css\" type=\"text/css\"?>";
	# must be the second line
	splice (@buf, 1, 0, ($css_include));

	print $svg_fh "$_\n" for (@buf);
	close $svg_fh;

	# we outputted something to a file, set stale to 0
	$success_sth->execute($manufacturer, $part_num_cased);
	$rendered_total++;
}

if ($args{v}) {
	print "\n";
	printf "info: %i rendered (%i skipped), %i series (%i points)\n",
		$rendered_total, $raw_total - $rendered_total, $series, $points;
}

$dbh->disconnect();

sub catmullrom_to_bezier
{
	my $pts_ref = shift;
	my @pts = @$pts_ref;

	# catmull-rom to cubic bezier conversion matrix
	# 0    1    0    0
	# -1/6 1    1/6  0
	# 0    1/6  1    -1/6
	# 0    0    1    0

	my $d = "M" . $pts[0] . ", " . $pts[1] . " ";
	my $iLen = @pts;
	for (my $i = 0; $iLen - 2 > $i; $i += 2) {
		my @p;
		if ($i == 0) {
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 4], y => $pts[$i + 5]};
		}
		elsif ($i == ($iLen - 4)) {
			push @p, {x => $pts[$i - 2], y => $pts[$i - 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
		}
		else {
			push @p, {x => $pts[$i - 2], y => $pts[$i - 1]};
			push @p, {x => $pts[$i], y => $pts[$i + 1]};
			push @p, {x => $pts[$i + 2], y => $pts[$i + 3]};
			push @p, {x => $pts[$i + 4], y => $pts[$i + 5]};
		}

		#	print Dumper(@p);

		my @bp;
		push @bp, {x => $p[1]{x}, y => $p[1]{y}};
		push @bp, {
			x => ((-$p[0]{x} + 6*$p[1]{x} + $p[2]{x}) / 6),
			y => ((-$p[0]{y} + 6*$p[1]{y} + $p[2]{y}) / 6)
		};
		push @bp, {
			x => (($p[1]{x} + 6*$p[2]{x} - $p[3]{x}) / 6),
			y => (($p[1]{y} + 6*$p[2]{y} - $p[3]{y}) / 6)
		};
		push @bp, {x => $p[2]{x}, y => $p[2]{y}};

		$d .= "C " . $bp[1]{x} . ", " . $bp[1]{y} . " " .
			$bp[2]{x} . ", " . $bp[2]{y} . " " .
			$bp[3]{x} . ", " . $bp[3]{y} . " ";
	}

	# print $d;
	return $d;
}

# function catmullRom2bezier( points ) {
#        // alert(points)
# var crp = points.split(/[,\s]/);
# var d = "";
# for (var i = 0, iLen = crp.length; iLen - 2 > i; i+=2) {
# 	var p = [];
# 	if ( 0 == i ) {
# 		p.push( {x: parseFloat(crp[ i ]), y: parseFloat(crp[ i + 1 ])} );
# 		p.push( {x: parseFloat(crp[ i ]), y: parseFloat(crp[ i + 1 ])} );
# 		p.push( {x: parseFloat(crp[ i + 2 ]), y: parseFloat(crp[ i + 3 ])} );
# 		p.push( {x: parseFloat(crp[ i + 4 ]), y: parseFloat(crp[ i + 5 ])} );
# 	} else if ( iLen - 4 == i ) {
# 		p.push( {x: parseFloat(crp[ i - 2 ]), y: parseFloat(crp[ i - 1 ])} );
# 		p.push( {x: parseFloat(crp[ i ]), y: parseFloat(crp[ i + 1 ])} );
# 		p.push( {x: parseFloat(crp[ i + 2 ]), y: parseFloat(crp[ i + 3 ])} );
# 		p.push( {x: parseFloat(crp[ i + 2 ]), y: parseFloat(crp[ i + 3 ])} );
# 	} else {
# 		p.push( {x: parseFloat(crp[ i - 2 ]), y: parseFloat(crp[ i - 1 ])} );
# 		p.push( {x: parseFloat(crp[ i ]), y: parseFloat(crp[ i + 1 ])} );
# 		p.push( {x: parseFloat(crp[ i + 2 ]), y: parseFloat(crp[ i + 3 ])} );
# 		p.push( {x: parseFloat(crp[ i + 4 ]), y: parseFloat(crp[ i + 5 ])} );
# 	}
#
# 	var bp = [];
# 	bp.push( { x: p[1].x, y: p[1].y } );
# 	bp.push( { x: ((-p[0].x + 6*p[1].x + p[2].x) / 6), y: ((-p[0].y + 6*p[1].y + p[2].y) / 6)} );
# 	bp.push( { x: ((p[1].x + 6*p[2].x - p[3].x) / 6), y: ((p[1].y + 6*p[2].y - p[3].y) / 6) } );
# 	bp.push( { x: p[2].x, y: p[2].y } );
#
# 	d += "C" + bp[1].x + "," + bp[1].y + " " + bp[2].x + "," + bp[2].y + " " + bp[3].x + "," + bp[3].y + " ";
# }
# return d;
# }
