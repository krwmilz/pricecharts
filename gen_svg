#!/usr/bin/env perl

use strict;
use warnings;

use Config::Grammar;
use Getopt::Std;
use SVG;
use POSIX;
use PriceChart;


my %args;
getopts("nv", \%args);

$| = 1 if ($args{v});

my $cfg = get_config();
my $dbh = get_dbh($cfg->{http}, undef, $args{v});

my $svg_dir = $cfg->{http}{chroot} . $cfg->{http}{htdocs} . "/svg";
xmkdir($svg_dir, $args{v});
print "info: svg output is $svg_dir\n" if ($args{v});

my ($left, $width, $right, $top, $height, $bottom) = (30, 900, 70, 20, 160, 20);
my $total_width = $right + $width + $left;
my $total_height = $top + $height + $bottom;

if ($args{v}) {
	print  "info: left, width, right, total  = $left, $width, $right, $total_width\n";
	print  "info: top, height, bottom, total = $top, $height, $bottom, $total_height\n";
}

my $sql = "select date, price, color from prices where " .
	"part_num = ? and vendor = ? order by date";
my $point_sth = $dbh->prepare($sql);

$sql = "select distinct vendor from prices where part_num = ?";
my $retailer_sth = $dbh->prepare($sql);

$sql = "select manufacturer, part_num, description from products";
my $parts_sth = $dbh->prepare($sql);

$parts_sth->execute();
print "info: generating svg's  " if ($args{v});
my ($raw_total, $rendered_total, $points, $series) = (0, 0, 0, 0);
while (my ($brand, $part_num, $description) = $parts_sth->fetchrow_array()) {
	$raw_total++;
	spin() if ($args{v});

	# make sure we have at least one price to work with
	$sql = "select min(date), max(date), min(price), max(price) " .
		"from prices where part_num = ?";
	my ($x_min, $x_max, $y_min, $y_max) =
		$dbh->selectrow_array($sql, undef, $part_num);
	next unless (defined $x_min);

	# avoid division by zero
	my ($domain, $range) = ($x_max - $x_min, $y_max - $y_min);
	$domain = (24 * 60 * 60) if ($domain < (24 * 60 * 60));
	$range = 20 if ($range < 20);

	# clamp the total size of this thing with viewBox
	my $svg = SVG->new(viewBox => "0 0 $total_width $total_height");
	my ($x_scale, $y_scale) = ($width / $domain, $height / $range);

	# render each retailer as a different series
	$retailer_sth->execute($part_num);
	while (my ($retailer) = $retailer_sth->fetchrow_array()) {
		my (@xs, @ys);
		my $line_color = "#000";

		# gather all points in the series
		$point_sth->execute($part_num, $retailer);
		while (my ($date, $price, $color) = $point_sth->fetchrow_array) {
			# transform and clamp real world coordinates
			push @xs, ($date - $x_min) * $x_scale + $left;
			push @ys, ($price - $y_min) * $y_scale + $top;

			# small filled in circles to indicate data points
			my $tag = $svg->anchor(
				-href => $cfg->{retailers}{$retailer}{search_url} . $part_num,
				target => "new_window"
			)->circle(
				cx => $xs[-1], cy => $ys[-1],
				r => 2,
				style => {
					"fill" => "#$color",
					"stroke" => "#$color"
				}
			);
			$line_color = $color;
			$points++;
		}
		my $points = $svg->get_path(
			x => \@xs, y => \@ys, -type => "polyline",
			-closed => "false"
		);

		# polyline sucks, spline would look nicer
		my $tag = $svg->anchor(
			-href => $cfg->{retailers}{$retailer}{search_url} . $part_num,
			target => "new_window"
		);
		$tag->polyline(
			%$points, id => $retailer,
			style => {
				"fill-opacity" => 0, fill => "#$line_color",
				stroke => "#$line_color", "stroke-width" => 2,
			}
		);
		$series++;
	}

	# when graph is loaded make a sliding motion show the graph lines
	my $mask = $svg->rectangle(
		x => 0, y => 0, width => 1000, height => 250, rx => 0, ry => 0,
		id => "mask", fill => "#FFF"
	);
	$mask->animate(
		attributeName => "x", values => "0;1000", dur => "0.8s",
		fill => "freeze", -method => ""
	);

	# prices along the side
	my $num_labels = 5;
	if ($range <= 20) {
		$num_labels = 2;
	}
	for (0..$num_labels) {
		my $price = $y_max - $range * $_ / $num_labels;
		my $y = $top + $height * $_ / $num_labels;

		$svg->text(
			id => $_, x => $left + $width + 20, y => $y,
			style => "font-size: 14px; fill: #666",
			"text-anchor" => "start"
		)->cdata("\$$price");

		$svg->line(
			id => "line_$_", x1 => $left, y1 => $y,
			x2 => $total_width - $right, y2 => $y,
			fill => "#CCC", stroke => "#CCC",
			"stroke-width" => 1,
		);
	}

	# dates along the bottom
	for (0..$num_labels) {
		my $time = $x_min + $_ * $domain / $num_labels;
		my $date = strftime "%b %e %Y", localtime($time);
		my $x = $left + $_ / $num_labels * $width;

		$svg->text(
			id => "time_$time",
			x => $x, y => $total_height,
			style => "font-size: 12px; fill: #666",
			"text-anchor" => "middle"
		)->cdata($date);

		$svg->line(
			id => "date_marker_$_",
			x1 => $x, y1 => $top + $height,
			x2 => $x, y2 => $top + $height + 5,
			fill => "#CCC",
			stroke => "#CCC",
			"stroke-width" => 1,
		);
	}

	next if ($args{n});

	# giant hack, if the part number has / in it, make some directories
	if ($part_num =~ /\//) {
		my $needed_dirs = substr($part_num, 0, rindex($part_num, '/'));
		xmkdir("$svg_dir/$needed_dirs", $args{v});
	}
	open my $svg_fh, ">", "$svg_dir/$part_num.svg" or
		die "couldn't open $svg_dir/$part_num: $!";
	print $svg_fh $svg->xmlify;
	close $svg_fh;

	$rendered_total++;
}

if ($args{v}) {
	print "\n";
	printf "info: %i svg's rendered (%i skipped), %i series (%i points)\n",
		$rendered_total, $raw_total - $rendered_total, $series, $points;
}

$dbh->disconnect();

my $state = 0;
sub spin
{
	my @spin_states = ("-", "\\", "|", "/");

	print "\b";
	print $spin_states[++$state % 4];
}
